export const dsaTopics = [
  {
    title: "Time and Space Complexity",
    description:
      "Analyzes the performance of algorithms in terms of runtime and memory usage. Helps in choosing the most efficient solution for a problem.",
  },
  {
    title: "Math",
    description:
      "Covers fundamental mathematical concepts like GCD, LCM, primes, and modular arithmetic. Often used in algorithm optimization and problem-solving.",
  },
  {
    title: "Bit Manipulation",
    description:
      "Involves operations on binary representations using AND, OR, XOR, etc. Useful for solving problems with space and performance constraints.",
  },
  {
    title: "Array",
    description:
      "A linear data structure used to store elements in contiguous memory. Foundation for many algorithmic techniques and problems.",
  },
  {
    title: "String",
    description:
      "Focuses on character arrays and operations like searching, matching, and manipulation. Key topic in interviews and text processing tasks.",
  },
  {
    title: "Two Pointer",
    description:
      "Uses two indices moving through data to solve problems efficiently. Common in array and string pattern problems.",
  },
  {
    title: "Sliding Window",
    description:
      "Optimizes subarray or substring problems by reusing results in a fixed-size or dynamic window. Reduces time complexity significantly.",
  },
  {
    title: "Hash Table",
    description:
      "Stores key-value pairs with constant time access. Powerful for frequency counting, indexing, and lookups.",
  },
  {
    title: "Stack",
    description:
      "A LIFO (Last In, First Out) structure used in parsing, backtracking, and expression evaluation. Supports push and pop operations.",
  },
  {
    title: "Queue",
    description:
      "A FIFO (First In, First Out) structure useful in BFS, scheduling, and stream processing. Comes in variants like circular and priority queues.",
  },
  {
    title: "Linked List",
    description:
      "A sequential data structure with nodes connected by pointers. Useful for dynamic memory allocation and efficient insertions/deletions.",
  },
  {
    title: "Prefix Sum",
    description:
      "Preprocessing technique to speed up range queries. Commonly used in subarray sum and difference problems.",
  },
  {
    title: "Binary Search",
    description:
      "Efficient algorithm for finding elements in sorted arrays in O(log n) time. Also used in search space problems.",
  },
  {
    title: "Recursion",
    description:
      "A technique where a function calls itself to solve smaller subproblems. Forms the base for divide-and-conquer strategies.",
  },
  {
    title: "Backtracking",
    description:
      "Explores all potential solutions and undoes choices when needed. Used in problems like permutations, combinations, and Sudoku.",
  },
  {
    title: "Sorting",
    description:
      "Organizes elements in a specific order. Includes bubble, merge, quick, and radix sort with varying time/space trade-offs.",
  },
  {
    title: "Greedy Algorithms",
    description:
      "Makes the locally optimal choice at each step for a global solution. Efficient for problems like interval scheduling and coin change.",
  },
  {
    title: "Trees",
    description:
      "Hierarchical data structures with parent-child relationships. Used in organizing data, file systems, and decision processes.",
  },
  {
    title: "Binary Tree",
    description:
      "Each node has up to two children. Fundamental for tree traversal techniques and many hierarchical problems.",
  },
  {
    title: "Binary Search Tree",
    description:
      "A binary tree where left < root < right. Enables fast lookup, insertion, and deletion in O(log n) time.",
  },
  {
    title: "Trie",
    description:
      "A tree-based structure for efficient string search and prefix matching. Commonly used in autocomplete systems.",
  },
  {
    title: "Heap",
    description:
      "A complete binary tree used to implement priority queues. Useful for scheduling, Dijkstra's algorithm, and more.",
  },
  {
    title: "Graph",
    description:
      "A collection of nodes (vertices) connected by edges. Represents networks, paths, and relationships.",
  },
  {
    title: "Graph Traversal",
    description:
      "Techniques like DFS and BFS to explore nodes. Forms the basis for many graph-based algorithms.",
  },
  {
    title: "Topological Sort",
    description:
      "Orders nodes in a directed acyclic graph (DAG). Used in task scheduling and dependency resolution.",
  },
  {
    title: "Union Find",
    description:
      "A disjoint set data structure for managing connected components. Commonly used in Kruskalâ€™s algorithm and cycle detection.",
  },
  {
    title: "Dynamic Programming",
    description:
      "Solves problems by breaking them into overlapping subproblems. Stores intermediate results to avoid recomputation.",
  },
  {
    title: "Memoization & Tabulation",
    description:
      "Memoization is top-down with caching; tabulation is bottom-up. Both are core techniques in dynamic programming.",
  },
  {
    title: "1D 2D DP",
    description:
      "Dynamic programming in one or two dimensions. Used in problems like knapsack, grid paths, and matrix chains.",
  },
  {
    title: "Bitmask DP",
    description:
      "Uses bitmasks to represent states in DP problems. Efficient for subsets, permutations, and TSP-like problems.",
  },
  {
    title: "DP on Trees",
    description:
      "Applies dynamic programming to tree structures. Used in counting paths, independent sets, and subtree problems.",
  },
  {
    title: "DP on Graphs",
    description:
      "Combines graph traversal with DP to solve shortest path, DAG-based, and constraint optimization problems.",
  },
  {
    title: "Segment Tree",
    description:
      "A binary tree structure for range queries and updates. Supports efficient min, max, sum operations on intervals.",
  },
  {
    title: "Monotonic Stack",
    description:
      "A stack that maintains increasing or decreasing order. Used in histogram, next greater/smaller element problems.",
  },
  {
    title: "Advanced Graph Algorithms",
    description:
      "Includes Dijkstra, Floyd-Warshall, Bellman-Ford, etc. Solves shortest path, flows, and network-related problems.",
  },
  {
    title: "Game Theory",
    description:
      "Analyzes strategic interactions and winning strategies. Covers concepts like Grundy numbers and minimax.",
  },
];
